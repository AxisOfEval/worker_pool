<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>wpool_pool</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>wpool_pool.xml</file></header>
<module>wpool_pool</module>
<modulesummary>A pool of workers.</modulesummary>
<description>
<p>A pool of workers. If you want to put it in your supervisor tree, remember it's a supervisor.</p></description>
<funcs>
<func>
<name>create_table() -&gt; ok</name>
<fsummary>Creates the ets table that will hold the information about currently active pools.</fsummary>

<desc><marker id="create_table-0"/>

<p>Creates the ets table that will hold the information about currently active pools</p>
</desc></func>
<func>
<name>start_link(Name::name() (see module wpool), Options::[option() (see module wpool)]) -&gt; {ok, pid()} | {error, {already_started, pid()} | term()}</name>
<fsummary>Starts a supervisor with several wpool_processes as its children.</fsummary>

<desc><marker id="start_link-2"/>

<p>Starts a supervisor with several <seealso marker="wpool_process">wpool_process</seealso>es as its children</p>
</desc></func>
<func>
<name>best_worker(Sup::name() (see module wpool)) -&gt; atom()</name>
<fsummary>Picks the worker with the smaller queue of messages.</fsummary>

<desc><marker id="best_worker-1"/>

<p>Picks the worker with the smaller queue of messages.
       Based on <url href="http://lethain.com/load-balancing-across-erlang-process-groups/">http://lethain.com/load-balancing-across-erlang-process-groups/</url></p>
</desc></func>
<func>
<name>random_worker(Sup::name() (see module wpool)) -&gt; atom()</name>
<fsummary>Picks a random worker.</fsummary>

<desc><marker id="random_worker-1"/>

<p>Picks a random worker</p>
</desc></func>
<func>
<name>next_worker(Sup::name() (see module wpool)) -&gt; atom()</name>
<fsummary>Picks the next worker in a round robin fashion.</fsummary>

<desc><marker id="next_worker-1"/>

<p>Picks the next worker in a round robin fashion</p>
</desc></func>
<func>
<name>available_worker(Sup::name() (see module wpool), Timeout::timeout()) -&gt; atom()</name>
<fsummary>Picks the first available worker.</fsummary>

<desc><marker id="available_worker-2"/>

<p>Picks the first available worker.
       If all workers are busy, waits for Timeout ms until one is free</p>
</desc></func>
<func>
<name>cast_to_available_worker(Sup::name() (see module wpool), Cast::term()) -&gt; ok</name>
<fsummary>Casts a message to the first available worker.</fsummary>

<desc><marker id="cast_to_available_worker-2"/>

<p>Casts a message to the first available worker.
       Since we can wait forever for a wpool:cast to be delivered
       but we don't want the caller to be blocked, this function
       just forwards the cast when it gets the worker</p>
</desc></func>
<func>
<name>stats(Sup::name() (see module wpool)) -&gt; stats() (see module wpool)</name>
<fsummary>Retrieves a snapshot of the pool stats.</fsummary>

<desc><marker id="stats-1"/>

<p>Retrieves a snapshot of the pool stats</p>
</desc></func>
<func>
<name>worker_names(Pool_Name::name() (see module wpool)) -&gt; [atom()]</name>
<fsummary>Returns the names of the workers in the pool.</fsummary>

<desc><marker id="worker_names-1"/>

<p>Returns the names of the workers in the pool</p>
</desc></func>
<func>
<name>wpool_size(Name::atom()) -&gt; non_neg_integer() | undefined</name>
<fsummary>the number of workers in the pool.</fsummary>

<desc><marker id="wpool_size-1"/>

<p>the number of workers in the pool</p>
</desc></func></funcs>

<authors>

<aname>Fernando Benavides</aname>
<email>elbrujohalcon@inaka.net</email></authors></erlref>